# MODFLOW 6 Input Data Model developer resource

MODFLOW 6 reads simulation input from text and binary input files.  Traditionally, each model package has been responsible for reading its own input.  Although there are low-level utilities for reading arrays, and parsing input blocks, these utilities are called from dedicated read routines for each package.  To support new types of input, such as from NetCDF files or through the Application Programming Interface, a new effort is underway to implement a comprehensive Input Data Model (IDM) for MODFLOW 6.  Implementation of an Output Data Model may follow this effort.

This document intends to describe, from a development perspective, the MODFLOW 6 IDM, and provide guidance for how to work with it. As the IDM is an active area of development this document should be expected to change frequently and will be updated to track with current state.

* [Overview](#overview)
* [Terminology](#terminology)
* [Package Update Process](#package-update-process)

## Overview
The MODFLOW 6 IDM is intended to provide a common entry point for simulation input data.  The approach is to read the input data first into memory and store the input data in the "input context."  Reading the simulation input into memory is performed by IDM load routines.  Model packages are then refactored so that they obtain their required information from the input context, rather than directly from the input files.  We refer to the process as "sourcing."  A model package "sources" its input from the input context.  The advantage here is that other readers can be implemented to load information into the input context, and then the model packages should work without modification.   This approach is built upon the MODFLOW 6 memory management infrastructure to define variable access paths that are scoped to a particular component/subcomponent. Input variables themselves are ultimately described by MODFLOW 6 definition (dfn) files.

The MODFLOW 6 IDM is intended to decouple a simulation run from any particular, supported source of input that a user might construct. Currently,  MODFLOW 6 packages read input directly from proprietary MODFLOW-specific input files as required during a simulation run. The new design assigns responsibility for reading and loading data from the files to IDM proper, which builds the input context from the supported user input source (currently, MODFLOW 6 input files). Simulation components then access (or source) the input context to retrieve relevant input data.

## Terminology
### Definition File (.dfn suffix)
MODFLOW 6 dfn file formats are described in the [dfn readme.md](../../doc/mf6io/mf6ivar/readme.md). These definition files describe MODFLOW 6 input files and parameters.  They are used to generate the documentation in mf6io.pdf.  They are also used to auto-generate the FloPy classes for MODFLOW 6. Definition files are also read as input to the dfn2f90.py script, which is a new utility developed as part of this IDM effort.  This script generates Fortran source code that describes MODFLOW 6 input.  The Fortran source code generated by dfn2f90.py defines the input parameters and input file structure, and is used by IDM to load simulation input.
### input definition
The Fortran version of the Input definitions are generated from MODFLOW 6 dfn files and describe input parameter or blocks:

```fortran
type(InputParamDefinitionType), parameter :: &
  gwtdsp_opt_xt3d_off = InputParamDefinitionType &
  ( &
  'GWT', & ! component
  'DSP', & ! subcomponent
  'OPTIONS', & ! block
  'XT3D_OFF', & ! tag name
  'XT3D_OFF', & ! fortran variable
  'KEYWORD', & ! type
  '', & ! shape
  .false., & ! required
  .false., & ! multi-record
  .false., & ! preserve case
  .false. & ! layered
  )
```    

These Fortran definitions are used by IDM input handlers to interpret user input and load input data into the input context.

A related set of input definitions are contained in a Fortran file that is named from the related package file, e.g. [gwf3npf8idm.f90](../../src/Model/GroundWaterFlow/gwf3npf8idm.f90) contains input definitions relevant to [gwf3npf8.f90](../../src/Model/GroundWaterFlow/gwf3npf8.f90). A Fortran input definition file is organized into 3 lists, a parameter (input variable) list, an aggregate (similar to a numpy recarray) list, and a block list.  The Fortran input definitions also contain the definition for a found type object that can be used within packages to track what input variable paths were loaded into the input context by the IDM load routine:

```fortran
type GwtDspParamFoundType
  logical :: opt_xt3d_off = .false.
  logical :: opt_xt3d_rhs = .false.
  logical :: grid_diffc = .false.
  logical :: grid_alh = .false.
  logical :: grid_alv = .false.
  logical :: grid_ath1 = .false.
  logical :: grid_ath2 = .false.
  logical :: grid_atv = .false.
end type GwtDspParamFoundType`
```
## Package Update process
###	Update [dfn2f90.py](scripts/dfn2f90.py)
Add a new dfns entry in main, designating paths and names for the input dfn and output f90 files.
### Run the dfn2f90.py script
```shell
cd utils/idmloader/scripts
python dfn2f90.py
```
This will create the new IDM Fortran definition file at the location designated.  This will also automatically update IDM selector modules so that the newly generated definitions can be used.  If a new component (e.g. a new model) has been introduced, a new selector file will be generated in the src/Utitilites/Idm/selector directory.
### Update [meson.build](../../src/meson.build) and [mf6core.vfproj](../../msvs/mf6core.vfproj)
Add any newly generated fortran files to relevant build scripts to compile new definitions and definition select routines into MODFLOW 6 binaries.

Note:  To simplify the update process, all necessary internal modifications are performed when dfn2f90.py is run.  Compiling with these changes immediately updates IDM to treat any newly added package as integrated.  This may not be the case if, for example, model package code has not been updated to source input from the input context.  GWF and GWT model code is fully integrated with IDM and as such either a valid unit number (for packages that are not IDM integrated) or a valid mempath (for packages that are IDM integrated) is passed into a package but not both.  Once a new fortran idm definition file has been compiled in, a valid unit number will no longer be provided to the package and parser operations will fail if attempted.
### Update the package file
#### Source package input data 
To convert a package to use the new IDM approach, the read routine for the package must be replaced by a sourcing routine that accesses data from the input context.  The implementation of the source routine is dependent on the data itself but a common pattern is to use the MemoryManagerExtModule `mem_set_value()` interface to copy data from the input context to package paths.  A parameter found type, in the generated IDM definition file, should be used to pass a corresponding logical to `mem_set_value()`, which sets the logical to True if the input path was found and data was copied.  When sourcing has been completed, the found type parameter logicals can be checked to determine what other actions need to be taken in response to both found or not found input data.

```fortran
character(len=LENMEMPATH) :: idmMemoryPath
type(GwtDspParamFoundType) :: found
! ------------------------------------------------------------------------------
!
! -- set memory path
idmMemoryPath = create_mem_path(this%name_model, 'DSP', idm_context)
!
! -- update defaults with idm sourced values
call mem_set_value(this%ixt3doff, 'XT3D_OFF', idmMemoryPath, found%opt_xt3d_off)
call mem_set_value(this%ixt3drhs, 'XT3D_RHS', idmMemoryPath, found%opt_xt3d_rhs)
!
! -- set xt3d state flag
if (found%opt_xt3d_off) this%ixt3d = 0
if (found%opt_xt3d_rhs) this%ixt3d = 2
```

#### Deallocate package input paths
In deallocate, add a call to MemoryManagerExtModule `memorylist_remove()` for the package.  This call will search the subcomponent input path and deallocate all memory that was allocated as part of the load process.

```fortran
! -- Deallocate input memory
call memorylist_remove(this%name_model, 'DSP', idm_context)
```

## Adding params to packages already using IDM

Once a model package has been modified to use the IDM approach, adding a new package option or block requires two steps.  The steps are as follows. 

### Update appropriate dfn file with new param(s)
### Run the dfn2f90.py script
```shell
cd utils/idmloader/scripts
python dfn2f90.py
```

This will update the existing idm package f90 file to add the new parameter definition.  Compile to update the binaries.
#### Source package input data
Update the package source routine for the relevant block to copy the data from the input path to the package path. Take any necessary action depending on whether the data was found or not found. 
